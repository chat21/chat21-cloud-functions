{
  "_args": [
    [
      {
        "raw": "protobufjs@https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
        "scope": null,
        "escapedName": "protobufjs",
        "name": "protobufjs",
        "rawSpec": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
        "spec": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
        "type": "remote"
      },
      "/Users/andrealeo/dev/chat21/chat21-firebase-cloud-functions-v2/functions/node_modules/firebase-admin"
    ]
  ],
  "_from": "protobufjs@https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
  "_id": "protobufjs@6.8.0",
  "_inCache": true,
  "_location": "/firebase-admin/google-gax/protobufjs",
  "_phantomChildren": {},
  "_requested": {
    "raw": "protobufjs@https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
    "scope": null,
    "escapedName": "protobufjs",
    "name": "protobufjs",
    "rawSpec": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
    "spec": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/firebase-admin/google-gax"
  ],
  "_resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
  "_shasum": "04e85493c4e1653878ec283f18bc78b1e7c5d5a2",
  "_shrinkwrap": null,
  "_spec": "protobufjs@https://registry.npmjs.org/protobufjs/-/protobufjs-6.8.0.tgz",
  "_where": "/Users/andrealeo/dev/chat21/chat21-firebase-cloud-functions-v2/functions/node_modules/firebase-admin",
  "author": {
    "name": "Daniel Wirtz",
    "email": "dcode+protobufjs@dcode.io"
  },
  "bin": {
    "pbjs": "bin/pbjs",
    "pbts": "bin/pbts"
  },
  "bugs": {
    "url": "https://github.com/dcodeIO/protobuf.js/issues"
  },
  "cliDependencies": [
    "semver",
    "chalk",
    "glob",
    "jsdoc",
    "minimist",
    "tmp",
    "uglify-js",
    "espree",
    "escodegen",
    "estraverse"
  ],
  "dependencies": {
    "@protobufjs/aspromise": "^1.1.2",
    "@protobufjs/base64": "^1.1.2",
    "@protobufjs/codegen": "^2.0.4",
    "@protobufjs/eventemitter": "^1.1.0",
    "@protobufjs/fetch": "^1.1.0",
    "@protobufjs/float": "^1.0.2",
    "@protobufjs/inquire": "^1.1.0",
    "@protobufjs/path": "^1.1.2",
    "@protobufjs/pool": "^1.1.0",
    "@protobufjs/utf8": "^1.1.0",
    "@types/long": "^3.0.31",
    "@types/node": "^7.0.29",
    "long": "^3.2.0"
  },
  "description": "Protocol Buffers for JavaScript (& TypeScript).",
  "devDependencies": {
    "benchmark": "^2.1.4",
    "browserify": "^14.4.0",
    "browserify-wrap": "^1.0.2",
    "bundle-collapser": "^1.2.1",
    "chalk": "^1.1.3",
    "escodegen": "^1.8.1",
    "eslint": "^3.19.0",
    "espree": "^3.4.3",
    "estraverse": "^4.2.0",
    "gh-pages": "^0.12.0",
    "git-raw-commits": "^1.2.0",
    "git-semver-tags": "^1.2.0",
    "glob": "^7.1.2",
    "google-protobuf": "^3.3.0",
    "gulp": "^3.9.1",
    "gulp-header": "^1.8.8",
    "gulp-if": "^2.0.1",
    "gulp-sourcemaps": "^2.6.0",
    "gulp-uglify": "^2.1.2",
    "istanbul": "^0.4.5",
    "jaguarjs-jsdoc": "github:dcodeio/jaguarjs-jsdoc",
    "jsdoc": "^3.4.2",
    "minimist": "^1.2.0",
    "node-zopfli": "^2.0.2",
    "reflect-metadata": "^0.1.10",
    "semver": "^5.3.0",
    "tap-spec": "^4.1.1",
    "tape": "^4.6.3",
    "tmp": "0.0.31",
    "tslint": "^5.4.3",
    "typescript": "^2.3.4",
    "uglify-js": "^2.8.28",
    "vinyl-buffer": "^1.0.0",
    "vinyl-fs": "^2.4.4",
    "vinyl-source-stream": "^1.1.0"
  },
  "homepage": "http://dcode.io/protobuf.js",
  "keywords": [
    "protobuf",
    "protocol-buffers",
    "serialization",
    "typescript"
  ],
  "license": "BSD-3-Clause",
  "main": "index.js",
  "name": "protobufjs",
  "optionalDependencies": {},
  "readme": "<h1><p align=\"center\"><img alt=\"protobuf.js\" src=\"https://github.com/dcodeIO/protobuf.js/raw/master/pbjs.png\" width=\"120\" height=\"104\" /></p></h1>\r\n<p align=\"center\"><a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/v/protobufjs.svg\" alt=\"\"></a> <a href=\"https://travis-ci.org/dcodeIO/protobuf.js\"><img src=\"https://travis-ci.org/dcodeIO/protobuf.js.svg?branch=master\" alt=\"\"></a> <a href=\"https://codeclimate.com/github/dcodeIO/protobuf.js/coverage\"><img src=\"https://codeclimate.com/github/dcodeIO/protobuf.js/badges/coverage.svg\" /></a> <a href=\"https://codeclimate.com/github/dcodeIO/protobuf.js\"><img src=\"https://codeclimate.com/github/dcodeIO/protobuf.js/badges/gpa.svg\" /></a> <a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/dm/protobufjs.svg\" alt=\"\"></a> <a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=dcode%40dcode.io&item_name=Open%20Source%20Software%20Donation&item_number=dcodeIO%2Fprotobuf.js\"><img alt=\"donate ❤\" src=\"https://img.shields.io/badge/donate-❤-ff2244.svg\"></a></p>\r\n\r\n**Protocol Buffers** are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more, originally designed at Google ([see](https://developers.google.com/protocol-buffers/)).\r\n\r\n**protobuf.js** is a pure JavaScript implementation with [TypeScript](https://www.typescriptlang.org) support for [node.js](https://nodejs.org) and the browser. It's easy to use, blazingly fast and works out of the box with [.proto](https://developers.google.com/protocol-buffers/docs/proto) files!\r\n\r\nContents\r\n--------\r\n\r\n* [Installation](#installation)<br />\r\n  How to include protobuf.js in your project.\r\n\r\n* [Usage](#usage)<br />\r\n  A brief introduction to using the toolset.\r\n\r\n  * [Valid Message](#valid-message)\r\n  * [Toolset](#toolset)<br />\r\n\r\n* [Examples](#examples)<br />\r\n  A few examples to get you started.\r\n\r\n  * [Using .proto files](#using-proto-files)\r\n  * [Using JSON descriptors](#using-json-descriptors)\r\n  * [Using reflection only](#using-reflection-only)\r\n  * [Using custom classes](#using-custom-classes)\r\n  * [Using services](#using-services)\r\n  * [Usage with TypeScript](#usage-with-typescript)<br />\r\n\r\n* [Command line](#command-line)<br />\r\n  How to use the command line utility.\r\n\r\n  * [pbjs for JavaScript](#pbjs-for-javascript)\r\n  * [pbts for TypeScript](#pbts-for-typescript)\r\n  * [Reflection vs. static code](#reflection-vs-static-code)\r\n  * [Command line API](#command-line-api)<br />\r\n\r\n* [Additional documentation](#additional-documentation)<br />\r\n  A list of available documentation resources.\r\n\r\n* [Performance](#performance)<br />\r\n  A few internals and a benchmark on performance.\r\n\r\n* [Compatibility](#compatibility)<br />\r\n  Notes on compatibility regarding browsers and optional libraries.\r\n\r\n* [Building](#building)<br />\r\n  How to build the library and its components yourself.\r\n\r\nInstallation\r\n---------------\r\n\r\n### node.js\r\n\r\n```\r\n$> npm install protobufjs [--save --save-prefix=~]\r\n```\r\n\r\n```js\r\nvar protobuf = require(\"protobufjs\");\r\n```\r\n\r\n**Note** that this library's versioning scheme is not semver-compatible for historical reasons. For guaranteed backward compatibility, always depend on `~6.A.B` instead of `^6.A.B` (hence the `--save-prefix` above).\r\n\r\n### Browsers\r\n\r\nDevelopment:\r\n\r\n```\r\n<script src=\"//cdn.rawgit.com/dcodeIO/protobuf.js/6.X.X/dist/protobuf.js\"></script>\r\n```\r\n\r\nProduction:\r\n\r\n```\r\n<script src=\"//cdn.rawgit.com/dcodeIO/protobuf.js/6.X.X/dist/protobuf.min.js\"></script>\r\n```\r\n\r\n**Remember** to replace the version tag with the exact [release](https://github.com/dcodeIO/protobuf.js/tags) your project depends upon.\r\n\r\nThe library supports CommonJS and AMD loaders and also exports globally as `protobuf`.\r\n\r\n### Distributions\r\n\r\nWhere bundle size is a factor, there are additional stripped-down versions of the [full library][dist-full] (~19kb gzipped) available that exclude certain functionality:\r\n\r\n* When working with JSON descriptors (i.e. generated by [pbjs](#pbjs-for-javascript)) and/or reflection only, see the [light library][dist-light] (~16kb gzipped) that excludes the parser. CommonJS entry point is:\r\n\r\n  ```js\r\n  var protobuf = require(\"protobufjs/light\");\r\n  ```\r\n\r\n* When working with statically generated code only, see the [minimal library][dist-minimal] (~6.5kb gzipped) that also excludes reflection. CommonJS entry point is:\r\n\r\n  ```js\r\n  var protobuf = require(\"protobufjs/minimal\");\r\n  ```\r\n\r\n[dist-full]: https://github.com/dcodeIO/protobuf.js/tree/master/dist\r\n[dist-light]: https://github.com/dcodeIO/protobuf.js/tree/master/dist/light\r\n[dist-minimal]: https://github.com/dcodeIO/protobuf.js/tree/master/dist/minimal\r\n\r\nUsage\r\n-----\r\n\r\nBecause JavaScript is a dynamically typed language, protobuf.js introduces the concept of a **valid message** in order to provide the best possible [performance](#performance) (and, as a side product, proper typings):\r\n\r\n### Valid message\r\n\r\n> A valid message is an object (1) not missing any required fields and (2) exclusively composed of JS types understood by the wire format writer.\r\n\r\nThere are two possible types of valid messages and the encoder is able to work with both of these for convenience:\r\n\r\n* **Message instances** (explicit instances of message classes with default values on their prototype) always (have to) satisfy the requirements of a valid message by design and\r\n* **Plain JavaScript objects** that just so happen to be composed in a way satisfying the requirements of a valid message as well.\r\n\r\nIn a nutshell, the wire format writer understands the following types:\r\n\r\n| Field type | Expected JS type (create, encode) | Conversion (fromObject)\r\n|------------|-----------------------------------|------------------------\r\n| s-/u-/int32<br />s-/fixed32 | `number` (32 bit integer) | <code>value &#124; 0</code> if signed<br />`value >>> 0` if unsigned\r\n| s-/u-/int64<br />s-/fixed64 | `Long`-like (optimal)<br />`number` (53 bit integer) | `Long.fromValue(value)` with long.js<br />`parseInt(value, 10)` otherwise\r\n| float<br />double | `number` | `Number(value)`\r\n| bool | `boolean` | `Boolean(value)`\r\n| string | `string` | `String(value)`\r\n| bytes | `Uint8Array` (optimal)<br />`Buffer` (optimal under node)<br />`Array.<number>` (8 bit integers) | `base64.decode(value)` if a `string`<br />`Object` with non-zero `.length` is assumed to be buffer-like\r\n| enum | `number` (32 bit integer) | Looks up the numeric id if a `string`\r\n| message | Valid message | `Message.fromObject(value)`\r\n\r\n* Explicit `undefined` and `null` are considered as not set if the field is optional.\r\n* Repeated fields are `Array.<T>`.\r\n* Map fields are `Object.<string,T>` with the key being the string representation of the respective value or an 8 characters long binary hash string for `Long`-likes.\r\n* Types marked as *optimal* provide the best performance because no conversion step (i.e. number to low and high bits or base64 string to buffer) is required.\r\n\r\n### Toolset\r\n\r\nWith that in mind and again for performance reasons, each message class provides a distinct set of methods with each method doing just one thing. This avoids unnecessary assertions / redundant operations where performance is a concern but also forces a user to perform verification (of plain JavaScript objects that *might* just so happen to be a valid message) explicitly where necessary - for example when dealing with user input.\r\n\r\n**Note** that `Message` below refers to any message class.\r\n\r\n* **Message.verify**(message: `Object`): `null|string`<br />\r\n  verifies that a **plain JavaScript object** satisfies the requirements of a valid message and thus can be encoded without issues. Instead of throwing, it returns the error message as a string, if any.\r\n\r\n  ```js\r\n  var payload = \"invalid (not an object)\";\r\n  var err = AwesomeMessage.verify(payload);\r\n  if (err)\r\n    throw Error(err);\r\n  ```\r\n\r\n* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />\r\n  encodes a **message instance** or valid **plain JavaScript object**. This method does not implicitly verify the message and it's up to the user to make sure that the payload is a valid message.\r\n\r\n  ```js\r\n  var buffer = AwesomeMessage.encode(message).finish();\r\n  ```\r\n\r\n* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`<br />\r\n  works like `Message.encode` but additionally prepends the length of the message as a varint.\r\n\r\n* **Message.decode**(reader: `Reader|Uint8Array`): `Message`<br />\r\n  decodes a buffer to a **message instance**. If required fields are missing, it throws a `util.ProtocolError` with an `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`.\r\n\r\n  ```js\r\n  try {\r\n    var decodedMessage = AwesomeMessage.decode(buffer);\r\n  } catch (e) {\r\n      if (e instanceof protobuf.util.ProtocolError) {\r\n        // e.instance holds the so far decoded message with missing required fields\r\n      } else {\r\n        // wire format is invalid\r\n      }\r\n  }\r\n  ```\r\n\r\n* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`<br />\r\n  works like `Message.decode` but additionally reads the length of the message prepended as a varint.\r\n\r\n* **Message.create**(properties: `Object`): `Message`<br />\r\n  creates a new **message instance** from a set of properties that satisfy the requirements of a valid message. Where applicable, it is recommended to prefer `Message.create` over `Message.fromObject` because it doesn't perform possibly redundant conversion.\r\n\r\n  ```js\r\n  var message = AwesomeMessage.create({ awesomeField: \"AwesomeString\" });\r\n  ```\r\n\r\n* **Message.fromObject**(object: `Object`): `Message`<br />\r\n  converts any non-valid **plain JavaScript object** to a **message instance** using the conversion steps outlined within the table above.\r\n\r\n  ```js\r\n  var message = AwesomeMessage.fromObject({ awesomeField: 42 });\r\n  // converts awesomeField to a string\r\n  ```\r\n\r\n* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`<br />\r\n  converts a **message instance** to an arbitrary **plain JavaScript object** for interoperability with other libraries or storage. The resulting plain JavaScript object *might* still satisfy the requirements of a valid message depending on the actual conversion options specified, but most of the time it does not.\r\n\r\n  ```js\r\n  var object = AwesomeMessage.toObject(message, {\r\n    enums: String,  // enums as string names\r\n    longs: String,  // longs as strings (requires long.js)\r\n    bytes: String,  // bytes as base64 encoded strings\r\n    defaults: true, // includes default values\r\n    arrays: true,   // populates empty arrays (repeated fields) even if defaults=false\r\n    objects: true,  // populates empty objects (map fields) even if defaults=false\r\n    oneofs: true    // includes virtual oneof fields set to the present field's name\r\n  });\r\n  ```\r\n\r\nFor reference, the following diagram aims to display relationships between the different methods and the concept of a valid message:\r\n\r\n<p align=\"center\"><img alt=\"Toolset Diagram\" src=\"http://dcode.io/protobuf.js/toolset.svg\" /></p>\r\n\r\n> In other words: `verify` indicates that calling `create` or `encode` directly on the plain object will [result in a valid message respectively] succeed. `fromObject`, on the other hand, does conversion from a broader range of plain objects to create valid messages. ([ref](https://github.com/dcodeIO/protobuf.js/issues/748#issuecomment-291925749))\r\n\r\nExamples\r\n--------\r\n\r\n### Using .proto files\r\n\r\nIt is possible to load existing .proto files using the full library, which parses and compiles the definitions to ready to use (reflection-based) message classes:\r\n\r\n```protobuf\r\n// awesome.proto\r\npackage awesomepackage;\r\nsyntax = \"proto3\";\r\n\r\nmessage AwesomeMessage {\r\n    string awesome_field = 1; // becomes awesomeField\r\n}\r\n```\r\n\r\n```js\r\nprotobuf.load(\"awesome.proto\", function(err, root) {\r\n    if (err)\r\n        throw err;\r\n\r\n    // Obtain a message type\r\n    var AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\");\r\n\r\n    // Exemplary payload\r\n    var payload = { awesomeField: \"AwesomeString\" };\r\n\r\n    // Verify the payload if necessary (i.e. when possibly incomplete or invalid)\r\n    var errMsg = AwesomeMessage.verify(payload);\r\n    if (errMsg)\r\n        throw Error(errMsg);\r\n\r\n    // Create a new message\r\n    var message = AwesomeMessage.create(payload); // or use .fromObject if conversion is necessary\r\n\r\n    // Encode a message to an Uint8Array (browser) or Buffer (node)\r\n    var buffer = AwesomeMessage.encode(message).finish();\r\n    // ... do something with buffer\r\n\r\n    // Decode an Uint8Array (browser) or Buffer (node) to a message\r\n    var message = AwesomeMessage.decode(buffer);\r\n    // ... do something with message\r\n\r\n    // If the application uses length-delimited buffers, there is also encodeDelimited and decodeDelimited.\r\n\r\n    // Maybe convert the message back to a plain object\r\n    var object = AwesomeMessage.toObject(message, {\r\n        longs: String,\r\n        enums: String,\r\n        bytes: String,\r\n        // see ConversionOptions\r\n    });\r\n});\r\n```\r\n\r\nAdditionally, promise syntax can be used by omitting the callback, if preferred:\r\n\r\n```js\r\nprotobuf.load(\"awesome.proto\")\r\n    .then(function(root) {\r\n       ...\r\n    });\r\n```\r\n\r\n### Using JSON descriptors\r\n\r\nThe library utilizes JSON descriptors that are equivalent to a .proto definition. For example, the following is identical to the .proto definition seen above:\r\n\r\n```json\r\n// awesome.json\r\n{\r\n  \"nested\": {\r\n    \"AwesomeMessage\": {\r\n      \"fields\": {\r\n        \"awesomeField\": {\r\n          \"type\": \"string\",\r\n          \"id\": 1\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nJSON descriptors closely resemble the internal reflection structure:\r\n\r\n| Type (T)           | Extends            | Type-specific properties\r\n|--------------------|--------------------|-------------------------\r\n| *ReflectionObject* |                    | options\r\n| *Namespace*        | *ReflectionObject* | nested\r\n| Root               | *Namespace*        | **nested**\r\n| Type               | *Namespace*        | **fields**\r\n| Enum               | *ReflectionObject* | **values**\r\n| Field              | *ReflectionObject* | rule, **type**, **id**\r\n| MapField           | Field              | **keyType**\r\n| OneOf              | *ReflectionObject* | **oneof** (array of field names)\r\n| Service            | *Namespace*        | **methods**\r\n| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream\r\n\r\n* **Bold properties** are required. *Italic types* are abstract.\r\n* `T.fromJSON(name, json)` creates the respective reflection object from a JSON descriptor\r\n* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)\r\n\r\nExclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required in this case).\r\n\r\nA JSON descriptor can either be loaded the usual way:\r\n\r\n```js\r\nprotobuf.load(\"awesome.json\", function(err, root) {\r\n    if (err) throw err;\r\n\r\n    // Continue at \"Obtain a message type\" above\r\n});\r\n```\r\n\r\nOr it can be loaded inline:\r\n\r\n```js\r\nvar jsonDescriptor = require(\"./awesome.json\"); // exemplary for node\r\n\r\nvar root = protobuf.Root.fromJSON(jsonDescriptor);\r\n\r\n// Continue at \"Obtain a message type\" above\r\n```\r\n\r\n### Using reflection only\r\n\r\nBoth the full and the light library include full reflection support. One could, for example, define the .proto definitions seen in the examples above using just reflection:\r\n\r\n```js\r\n...\r\nvar Root  = protobuf.Root,\r\n    Type  = protobuf.Type,\r\n    Field = protobuf.Field;\r\n\r\nvar AwesomeMessage = new Type(\"AwesomeMessage\").add(new Field(\"awesomeField\", 1, \"string\"));\r\n\r\nvar root = new Root().define(\"awesomepackage\").add(AwesomeMessage);\r\n\r\n// Continue at \"Create a new message\" above\r\n...\r\n```\r\n\r\nDetailed information on the reflection structure is available within the [API documentation](#additional-documentation).\r\n\r\n### Using custom classes\r\n\r\nMessage classes can also be extended with custom functionality and it is also possible to register a custom constructor with a reflected message type:\r\n\r\n```js\r\n...\r\n\r\n// Define a custom constructor\r\nfunction AwesomeMessage(properties) {\r\n    // custom initialization code\r\n    ...\r\n}\r\n\r\n// Register the custom constructor with its reflected type (*)\r\nroot.lookupType(\"awesomepackage.AwesomeMessage\").ctor = AwesomeMessage;\r\n\r\n// Define custom functionality\r\nAwesomeMessage.customStaticMethod = function() { ... };\r\nAwesomeMessage.prototype.customInstanceMethod = function() { ... };\r\n\r\n// Continue at \"Create a new message\" above\r\n```\r\n\r\n(*) Besides referencing its reflected type through `AwesomeMessage.$type` and `AwesomeMesage#$type`, the respective custom class is automatically populated with:\r\n\r\n* `AwesomeMessage.create`\r\n* `AwesomeMessage.encode` and `AwesomeMessage.encodeDelimited`\r\n* `AwesomeMessage.decode` and `AwesomeMessage.decodeDelimited`\r\n* `AwesomeMessage.verify`\r\n* `AwesomeMessage.fromObject`, `AwesomeMessage.toObject`, `AwesomeMessage#toObject` and `AwesomeMessage#toJSON`\r\n\r\nAfterwards, decoded messages of this type are `instanceof AwesomeMessage`.\r\n\r\nAlternatively, it is also possible to reuse and extend the internal constructor if custom initialization code is not required:\r\n\r\n```js\r\n...\r\n\r\n// Reuse the internal constructor\r\nvar AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\").ctor;\r\n\r\n// Define custom functionality\r\nAwesomeMessage.customStaticMethod = function() { ... };\r\nAwesomeMessage.prototype.customInstanceMethod = function() { ... };\r\n\r\n// Continue at \"Create a new message\" above\r\n```\r\n\r\n### Using services\r\n\r\nThe library also supports consuming services but it doesn't make any assumptions about the actual transport channel. Instead, a user must provide a suitable RPC implementation, which is an asynchronous function that takes the reflected service method, the binary request and a node-style callback as its parameters:\r\n\r\n```js\r\nfunction rpcImpl(method, requestData, callback) {\r\n    // perform the request using an HTTP request or a WebSocket for example\r\n    var responseData = ...;\r\n    // and call the callback with the binary response afterwards:\r\n    callback(null, responseData);\r\n}\r\n```\r\n\r\nExample:\r\n\r\n```protobuf\r\n// greeter.proto\r\nsyntax = \"proto3\";\r\n\r\nservice Greeter {\r\n    rpc SayHello (HelloRequest) returns (HelloReply) {}\r\n}\r\n\r\nmessage HelloRequest {\r\n    string name = 1;\r\n}\r\n\r\nmessage HelloReply {\r\n    string message = 1;\r\n}\r\n```\r\n\r\n```js\r\n...\r\nvar Greeter = root.lookup(\"Greeter\");\r\nvar greeter = Greeter.create(/* see above */ rpcImpl, /* request delimited? */ false, /* response delimited? */ false);\r\n\r\ngreeter.sayHello({ name: 'you' }, function(err, response) {\r\n    console.log('Greeting:', response.message);\r\n});\r\n```\r\n\r\nServices also support promises:\r\n\r\n```js\r\ngreeter.sayHello({ name: 'you' })\r\n    .then(function(response) {\r\n        console.log('Greeting:', response.message);\r\n    });\r\n```\r\n\r\nThere is also an [example for streaming RPC](https://github.com/dcodeIO/protobuf.js/blob/master/examples/streaming-rpc.js).\r\n\r\nNote that the service API is meant for clients. Implementing a server-side endpoint pretty much always requires transport channel (i.e. http, websocket, etc.) specific code with the only common denominator being that it decodes and encodes messages.\r\n\r\n### Usage with TypeScript\r\n\r\nThe library ships with its own [type definitions](https://github.com/dcodeIO/protobuf.js/blob/master/index.d.ts) and modern editors like [Visual Studio Code](https://code.visualstudio.com/) will automatically detect and use them for code completion.\r\n\r\nThe npm package depends on [@types/node](https://www.npmjs.com/package/@types/node) because of `Buffer` and [@types/long](https://www.npmjs.com/package/@types/long) because of `Long`. If you are not building for node and/or not using long.js, it should be safe to exclude them manually.\r\n\r\n#### Using the JS API\r\n\r\nThe API shown above works pretty much the same with TypeScript. However, because everything is typed, accessing fields on instances of dynamically generated message classes requires either using bracket-notation (i.e. `message[\"awesomeField\"]`) or explicit casts. Alternatively, it is possible to use a [typings file generated for its static counterpart](#pbts-for-typescript).\r\n\r\n```ts\r\nimport { load } from \"protobufjs\"; // respectively \"./node_modules/protobufjs\"\r\n\r\nload(\"awesome.proto\", function(err, root) {\r\n  if (err)\r\n    throw err;\r\n\r\n  // example code\r\n  const AwesomeMessage = root.lookupType(\"awesomepackage.AwesomeMessage\");\r\n\r\n  let message = AwesomeMessage.create({ awesomeField: \"hello\" });\r\n  console.log(`message = ${JSON.stringify(message)}`);\r\n\r\n  let buffer = AwesomeMessage.encode(message).finish();\r\n  console.log(`buffer = ${Array.prototype.toString.call(buffer)}`);\r\n\r\n  let decoded = AwesomeMessage.decode(buffer);\r\n  console.log(`decoded = ${JSON.stringify(decoded)}`);\r\n});\r\n```\r\n\r\n#### Using generated static code\r\n\r\nIf you generated static code to `bundle.js` using the CLI and its type definitions to `bundle.d.ts`, then you can just do:\r\n\r\n```ts\r\nimport { AwesomeMessage } from \"./bundle.js\";\r\n\r\n// example code\r\nlet message = AwesomeMessage.create({ awesomeField: \"hello\" });\r\nlet buffer  = AwesomeMessage.encode(message).finish();\r\nlet decoded = AwesomeMessage.decode(buffer);\r\n```\r\n\r\n#### Using decorators\r\n\r\nThe library also includes an early implementation of [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html).\r\n\r\n**Note** that decorators are an experimental feature in TypeScript and that declaration order is important depending on the JS target. For example, `@Field.d(2, AwesomeArrayMessage)` requires that `AwesomeArrayMessage` has been defined earlier when targeting `ES5`.\r\n\r\n```ts\r\nimport { Message, Type, Field, OneOf } from \"protobufjs/light\"; // respectively \"./node_modules/protobufjs/light.js\"\r\n\r\nexport class AwesomeSubMessage extends Message<AwesomeSubMessage> {\r\n\r\n  @Field.d(1, \"string\")\r\n  public awesomeString: string;\r\n\r\n}\r\n\r\nexport enum AwesomeEnum {\r\n  ONE = 1,\r\n  TWO = 2\r\n}\r\n\r\n@Type.d(\"SuperAwesomeMessage\")\r\nexport class AwesomeMessage extends Message<AwesomeMessage> {\r\n\r\n  @Field.d(1, \"string\", \"optional\", \"awesome default string\")\r\n  public awesomeField: string;\r\n\r\n  @Field.d(2, AwesomeSubMessage)\r\n  public awesomeSubMessage: AwesomeSubMessage;\r\n\r\n  @Field.d(3, AwesomeEnum, \"optional\", AwesomeEnum.ONE)\r\n  public awesomeEnum: AwesomeEnum;\r\n\r\n  @OneOf.d(\"awesomeSubMessage\", \"awesomeEnum\")\r\n  public which: string;\r\n\r\n}\r\n\r\n// example code\r\nlet message = new AwesomeMessage({ awesomeField: \"hello\" });\r\nlet buffer  = AwesomeMessage.encode(message).finish();\r\nlet decoded = AwesomeMessage.decode(buffer);\r\n```\r\n\r\nSupported decorators are:\r\n\r\n* **Type.d(typeName?: `string`)** &nbsp; *(optional)*<br />\r\n  annotates a class as a protobuf message type. If `typeName` is not specified, the constructor's runtime function name is used for the reflected type.\r\n\r\n* **Field.d&lt;T>(fieldId: `number`, fieldType: `string | Constructor<T>`, fieldRule?: `\"optional\" | \"required\" | \"repeated\"`, defaultValue?: `T`)**<br />\r\n  annotates a property as a protobuf field with the specified id and protobuf type.\r\n\r\n* **MapField.d&lt;T extends { [key: string]: any }>(fieldId: `number`, fieldKeyType: `string`, fieldValueType. `string | Constructor<{}>`)**<br />\r\n  annotates a property as a protobuf map field with the specified id, protobuf key and value type.\r\n\r\n* **OneOf.d&lt;T extends string>(...fieldNames: `string[]`)**<br />\r\n  annotates a property as a protobuf oneof covering the specified fields.\r\n\r\nOther notes:\r\n\r\n* Decorated types reside in `protobuf.roots[\"decorated\"]` using a flat structure, so no duplicate names.\r\n* Enums are copied to a reflected enum with a generic name on decorator evaluation because referenced enum objects have no runtime name the decorator could use.\r\n* Default values must be specified as arguments to the decorator instead of using a property initializer for proper prototype behavior.\r\n* Property names on decorated classes must not be renamed on compile time (i.e. by a minifier) because decorators just receive the original field name as a string.\r\n\r\n**ProTip!** Not as pretty, but you can [use decorators in plain JavaScript](https://github.com/dcodeIO/protobuf.js/blob/master/examples/js-decorators.js) as well.\r\n\r\nCommand line\r\n------------\r\n\r\n**Note** that moving the CLI to [its own package](./cli) is a work in progress. At the moment, it's still part of the main package.\r\n\r\nThe command line interface (CLI) can be used to translate between file formats and to generate static code as well as TypeScript definitions.\r\n\r\n### pbjs for JavaScript\r\n\r\n```\r\nTranslates between file formats and generates static code.\r\n\r\n  -t, --target     Specifies the target format. Also accepts a path to require a custom target.\r\n\r\n                   json          JSON representation\r\n                   json-module   JSON representation as a module\r\n                   proto2        Protocol Buffers, Version 2\r\n                   proto3        Protocol Buffers, Version 3\r\n                   static        Static code without reflection (non-functional on its own)\r\n                   static-module Static code without reflection as a module\r\n\r\n  -p, --path       Adds a directory to the include path.\r\n\r\n  -o, --out        Saves to a file instead of writing to stdout.\r\n\r\n  --sparse         Exports only those types referenced from a main file (experimental).\r\n\r\n  Module targets only:\r\n\r\n  -w, --wrap       Specifies the wrapper to use. Also accepts a path to require a custom wrapper.\r\n\r\n                   default   Default wrapper supporting both CommonJS and AMD\r\n                   commonjs  CommonJS wrapper\r\n                   amd       AMD wrapper\r\n                   es6       ES6 wrapper (implies --es6)\r\n                   closure   A closure adding to protobuf.roots where protobuf is a global\r\n\r\n  -r, --root       Specifies an alternative protobuf.roots name.\r\n\r\n  -l, --lint       Linter configuration. Defaults to protobuf.js-compatible rules:\r\n\r\n                   eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins\r\n\r\n  --es6            Enables ES6 syntax (const/let instead of var)\r\n\r\n  Proto sources only:\r\n\r\n  --keep-case      Keeps field casing instead of converting to camel case.\r\n\r\n  Static targets only:\r\n\r\n  --no-create      Does not generate create functions used for reflection compatibility.\r\n  --no-encode      Does not generate encode functions.\r\n  --no-decode      Does not generate decode functions.\r\n  --no-verify      Does not generate verify functions.\r\n  --no-convert     Does not generate convert functions like from/toObject\r\n  --no-delimited   Does not generate delimited encode/decode functions.\r\n  --no-beautify    Does not beautify generated code.\r\n  --no-comments    Does not output any JSDoc comments.\r\n\r\n  --force-long     Enfores the use of 'Long' for s-/u-/int64 and s-/fixed64 fields.\r\n  --force-message  Enfores the use of message instances instead of plain objects.\r\n\r\nusage: pbjs [options] file1.proto file2.json ...  (or pipe)  other | pbjs [options] -\r\n```\r\n\r\nFor production environments it is recommended to bundle all your .proto files to a single .json file, which minimizes the number of network requests and avoids any parser overhead (hint: works with just the **light** library):\r\n\r\n```\r\n$> pbjs -t json file1.proto file2.proto > bundle.json\r\n```\r\n\r\nNow, either include this file in your final bundle:\r\n\r\n```js\r\nvar root = protobuf.Root.fromJSON(require(\"./bundle.json\"));\r\n```\r\n\r\nor load it the usual way:\r\n\r\n```js\r\nprotobuf.load(\"bundle.json\", function(err, root) {\r\n    ...\r\n});\r\n```\r\n\r\nGenerated static code, on the other hand, works with just the **minimal** library. For example\r\n\r\n```\r\n$> pbjs -t static-module -w commonjs -o compiled.js file1.proto file2.proto\r\n```\r\n\r\nwill generate static code for definitions within `file1.proto` and `file2.proto` to a CommonJS module `compiled.js`.\r\n\r\n**ProTip!** Documenting your .proto files with `/** ... */`-blocks or (trailing) `/// ...` lines translates to generated static code.\r\n\r\n\r\n### pbts for TypeScript\r\n\r\n```\r\nGenerates TypeScript definitions from annotated JavaScript files.\r\n\r\n  -o, --out       Saves to a file instead of writing to stdout.\r\n\r\n  -g, --global    Name of the global object in browser environments, if any.\r\n\r\n  --no-comments   Does not output any JSDoc comments.\r\n\r\n  Internal flags:\r\n\r\n  -n, --name      Wraps everything in a module of the specified name.\r\n\r\n  -m, --main      Whether building the main library without any imports.\r\n\r\nusage: pbts [options] file1.js file2.js ...  (or)  other | pbts [options] -\r\n```\r\n\r\nPicking up on the example above, the following not only generates static code to a CommonJS module `compiled.js` but also its respective TypeScript definitions to `compiled.d.ts`:\r\n\r\n```\r\n$> pbjs -t static-module -w commonjs -o compiled.js file1.proto file2.proto\r\n$> pbts -o compiled.d.ts compiled.js\r\n```\r\n\r\nAdditionally, TypeScript definitions of static modules are compatible with their reflection-based counterparts (i.e. as exported by JSON modules), as long as the following conditions are met:\r\n\r\n1. Instead of using `new SomeMessage(...)`, always use `SomeMessage.create(...)` because reflection objects do not provide a constructor.\r\n2. Types, services and enums must start with an uppercase letter to become available as properties of the reflected types as well (i.e. to be able to use `MyMessage.MyEnum` instead of `root.lookup(\"MyMessage.MyEnum\")`).\r\n\r\nFor example, the following generates a JSON module `bundle.js` and a `bundle.d.ts`, but no static code:\r\n\r\n```\r\n$> pbjs -t json-module -w commonjs -o bundle.js file1.proto file2.proto\r\n$> pbjs -t static-module file1.proto file2.proto | pbts -o bundle.d.ts -\r\n```\r\n\r\n### Reflection vs. static code\r\n\r\nWhile using .proto files directly requires the full library respectively pure reflection/JSON the light library, pretty much all code but the relatively short descriptors is shared.\r\n\r\nStatic code, on the other hand, requires just the minimal library, but generates additional source code without any reflection features. This also implies that there is a break-even point where statically generated code becomes larger than descriptor-based code once the amount of code generated exceeds the size of the full respectively light library.\r\n\r\nThere is no significant difference performance-wise as the code generated statically is pretty much the same as generated at runtime and both are largely interchangeable as seen in the previous section.\r\n\r\n| Source | Library | Advantages | Tradeoffs\r\n|--------|---------|------------|-----------\r\n| .proto | full    | Easily editable<br />Interoperability with other libraries<br />No compile step | Some parsing and possibly network overhead\r\n| JSON   | light   | Easily editable<br />No parsing overhead<br />Single bundle (no network overhead) | protobuf.js specific<br />Has a compile step\r\n| static | minimal | Works where `eval` access is restricted<br />Fully documented<br />Small footprint for small protos | Can be hard to edit<br />No reflection<br />Has a compile step\r\n\r\n### Command line API\r\n\r\nBoth utilities can be used programmatically by providing command line arguments and a callback to their respective `main` functions:\r\n\r\n```js\r\nvar pbjs = require(\"protobufjs/cli/pbjs\"); // or require(\"protobufjs/cli\").pbjs / .pbts\r\n\r\npbjs.main([ \"--target\", \"json-module\", \"path/to/myproto.proto\" ], function(err, output) {\r\n    if (err)\r\n        throw err;\r\n    // do something with output\r\n});\r\n```\r\n\r\nAdditional documentation\r\n------------------------\r\n\r\n#### Protocol Buffers\r\n* [Google's Developer Guide](https://developers.google.com/protocol-buffers/docs/overview)\r\n\r\n#### protobuf.js\r\n* [API Documentation](http://dcode.io/protobuf.js)\r\n* [CHANGELOG](https://github.com/dcodeIO/protobuf.js/blob/master/CHANGELOG.md)\r\n* [Frequently asked questions](https://github.com/dcodeIO/protobuf.js/wiki) on our wiki\r\n\r\n#### Community\r\n* [Questions and answers](http://stackoverflow.com/search?tab=newest&q=protobuf.js) on StackOverflow\r\n\r\nPerformance\r\n-----------\r\nThe package includes a benchmark that compares protobuf.js performance to native JSON (as far as this is possible) and [Google's JS implementation](https://github.com/google/protobuf/tree/master/js). On an i7-2600K running node 6.9.1 it yields:\r\n\r\n```\r\nbenchmarking encoding performance ...\r\n\r\nprotobuf.js (reflect) x 541,707 ops/sec ±1.13% (87 runs sampled)\r\nprotobuf.js (static) x 548,134 ops/sec ±1.38% (89 runs sampled)\r\nJSON (string) x 318,076 ops/sec ±0.63% (93 runs sampled)\r\nJSON (buffer) x 179,165 ops/sec ±2.26% (91 runs sampled)\r\ngoogle-protobuf x 74,406 ops/sec ±0.85% (86 runs sampled)\r\n\r\n   protobuf.js (static) was fastest\r\n  protobuf.js (reflect) was 0.9% ops/sec slower (factor 1.0)\r\n          JSON (string) was 41.5% ops/sec slower (factor 1.7)\r\n          JSON (buffer) was 67.6% ops/sec slower (factor 3.1)\r\n        google-protobuf was 86.4% ops/sec slower (factor 7.3)\r\n\r\nbenchmarking decoding performance ...\r\n\r\nprotobuf.js (reflect) x 1,383,981 ops/sec ±0.88% (93 runs sampled)\r\nprotobuf.js (static) x 1,378,925 ops/sec ±0.81% (93 runs sampled)\r\nJSON (string) x 302,444 ops/sec ±0.81% (93 runs sampled)\r\nJSON (buffer) x 264,882 ops/sec ±0.81% (93 runs sampled)\r\ngoogle-protobuf x 179,180 ops/sec ±0.64% (94 runs sampled)\r\n\r\n  protobuf.js (reflect) was fastest\r\n   protobuf.js (static) was 0.3% ops/sec slower (factor 1.0)\r\n          JSON (string) was 78.1% ops/sec slower (factor 4.6)\r\n          JSON (buffer) was 80.8% ops/sec slower (factor 5.2)\r\n        google-protobuf was 87.0% ops/sec slower (factor 7.7)\r\n\r\nbenchmarking combined performance ...\r\n\r\nprotobuf.js (reflect) x 275,900 ops/sec ±0.78% (90 runs sampled)\r\nprotobuf.js (static) x 290,096 ops/sec ±0.96% (90 runs sampled)\r\nJSON (string) x 129,381 ops/sec ±0.77% (90 runs sampled)\r\nJSON (buffer) x 91,051 ops/sec ±0.94% (90 runs sampled)\r\ngoogle-protobuf x 42,050 ops/sec ±0.85% (91 runs sampled)\r\n\r\n   protobuf.js (static) was fastest\r\n  protobuf.js (reflect) was 4.7% ops/sec slower (factor 1.0)\r\n          JSON (string) was 55.3% ops/sec slower (factor 2.2)\r\n          JSON (buffer) was 68.6% ops/sec slower (factor 3.2)\r\n        google-protobuf was 85.5% ops/sec slower (factor 6.9)\r\n```\r\n\r\nThese results are achieved by\r\n\r\n* generating type-specific encoders, decoders, verifiers and converters at runtime\r\n* configuring the reader/writer interface according to the environment\r\n* using node-specific functionality where beneficial and, of course\r\n* avoiding unnecessary operations through splitting up [the toolset](#toolset).\r\n\r\nYou can also run [the benchmark](https://github.com/dcodeIO/protobuf.js/blob/master/bench/index.js) ...\r\n\r\n```\r\n$> npm run bench\r\n```\r\n\r\nand [the profiler](https://github.com/dcodeIO/protobuf.js/blob/master/bench/prof.js) yourself (the latter requires a recent version of node):\r\n\r\n```\r\n$> npm run prof <encode|decode|encode-browser|decode-browser> [iterations=10000000]\r\n```\r\n\r\nNote that as of this writing, the benchmark suite performs significantly slower on node 7.2.0 compared to 6.9.1 because moths.\r\n\r\nCompatibility\r\n-------------\r\n\r\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/protobuf.svg)](https://saucelabs.com/u/protobuf)\r\n\r\n* Because the internals of this package do not rely on `google/protobuf/descriptor.proto`, options are parsed and presented literally.\r\n* If typed arrays are not supported by the environment, plain arrays will be used instead.\r\n* Support for pre-ES5 environments (except IE8) can be achieved by [using a polyfill](https://github.com/dcodeIO/protobuf.js/blob/master/scripts/polyfill.js).\r\n* Support for [Content Security Policy](https://w3c.github.io/webappsec-csp/)-restricted environments (like Chrome extensions without [unsafe-eval](https://developer.chrome.com/extensions/contentSecurityPolicy#relaxing-eval)) can be achieved by generating and using static code instead.\r\n* If a proper way to work with 64 bit values (uint64, int64 etc.) is required, just install [long.js](https://github.com/dcodeIO/long.js) alongside this library. All 64 bit numbers will then be returned as a `Long` instance instead of a possibly unsafe JavaScript number ([see](https://github.com/dcodeIO/long.js)).\r\n* For descriptor.proto interoperability, see [ext/descriptor](https://github.com/dcodeIO/protobuf.js/tree/master/ext/descriptor)\r\n\r\nBuilding\r\n--------\r\n\r\nTo build the library or its components yourself, clone it from GitHub and install the development dependencies:\r\n\r\n```\r\n$> git clone https://github.com/dcodeIO/protobuf.js.git\r\n$> cd protobuf.js\r\n$> npm install\r\n```\r\n\r\nBuilding the respective development and production versions with their respective source maps to `dist/`:\r\n\r\n```\r\n$> npm run build\r\n```\r\n\r\nBuilding the documentation to `docs/`:\r\n\r\n```\r\n$> npm run docs\r\n```\r\n\r\nBuilding the TypeScript definition to `index.d.ts`:\r\n\r\n```\r\n$> npm run types\r\n```\r\n\r\n### Browserify integration\r\n\r\nBy default, protobuf.js integrates into any browserify build-process without requiring any optional modules. Hence:\r\n\r\n* If int64 support is required, explicitly require the `long` module somewhere in your project as it will be excluded otherwise. This assumes that a global `require` function is present that protobuf.js can call to obtain the long module.\r\n\r\n  If there is no global `require` function present after bundling, it's also possible to assign the long module programmatically:\r\n\r\n  ```js\r\n  var Long = ...;\r\n  \r\n  protobuf.util.Long = Long;\r\n  protobuf.configure();\r\n  ```\r\n\r\n* If you have any special requirements, there is [the bundler](https://github.com/dcodeIO/protobuf.js/blob/master/scripts/bundle.js) for reference.\r\n\r\n**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dcodeIO/protobuf.js.git"
  },
  "scripts": {
    "bench": "node bench",
    "build": "gulp --gulpfile scripts/gulpfile.js",
    "changelog": "node scripts/changelog -w",
    "coverage": "istanbul --config=config/istanbul.json cover node_modules/tape/bin/tape tests/*.js tests/node/*.js",
    "coverage-ci": "npm run coverage && codeclimate-test-reporter < coverage/lcov.info",
    "docs": "jsdoc -c config/jsdoc.json -R README.md --verbose --pedantic",
    "lint": "eslint **/*.js -c config/eslint.json && tslint **/*.d.ts -e **/node_modules/** -t stylish -c config/tslint.json",
    "make": "npm run test && npm run types && npm run build && npm run lint",
    "pages": "node scripts/pages",
    "postinstall": "node scripts/postinstall",
    "prepublish": "node scripts/prepublish",
    "prof": "node bench/prof",
    "release": "npm run make && npm run changelog",
    "test": "tape -r ./lib/tape-adapter tests/*.js tests/node/*.js | tap-spec",
    "test-types": "tsc tests/comp_typescript.ts --lib es2015 --strictNullChecks --experimentalDecorators --emitDecoratorMetadata && tsc tests/data/test.ts --lib es2015 --noEmit --strictNullChecks && tsc tests/data/rpc.ts --lib es2015 --noEmit --strictNullChecks",
    "types": "node bin/pbts --main --global protobuf --out index.d.ts src/ lib/aspromise/index.js lib/base64/index.js lib/codegen/index.js lib/eventemitter/index.js lib/float/index.js lib/fetch/index.js lib/inquire/index.js lib/path/index.js lib/pool/index.js lib/utf8/index.js && npm run test-types",
    "zuul": "zuul --ui tape --no-coverage --concurrency 4 -- tests/*.js",
    "zuul-local": "zuul --ui tape --concurrency 1 --local 8080 --disable-tunnel -- tests/*.js"
  },
  "types": "index.d.ts",
  "version": "6.8.0",
  "versionScheme": "~"
}
